
#include <filesystem>
#include "CLI11.hpp"
#include "../include/Battery/Utils/OsString.h"
namespace fs = std::filesystem;
using Battery::OsString;

enum class ErrorCode {
    SUCCESS = 0,
    INPUT_FILE_FAILED = -1,
    OUTPUT_FILE_FAILED = -2,
    OUTPUT_HEADER_FILE_FAILED = -3
};

// Using lookup tables for converting ints to hex strings, for best performance
size_t write_hex_comma(char* buf, uint8_t num) {
    static const char lut[513] =
        "000102030405060708090a0b0c0d0e0f"
        "101112131415161718191a1b1c1d1e1f"
        "202122232425262728292a2b2c2d2e2f"
        "303132333435363738393a3b3c3d3e3f"
        "404142434445464748494a4b4c4d4e4f"
        "505152535455565758595a5b5c5d5e5f"
        "606162636465666768696a6b6c6d6e6f"
        "707172737475767778797a7b7c7d7e7f"
        "808182838485868788898a8b8c8d8e8f"
        "909192939495969798999a9b9c9d9e9f"
        "a0a1a2a3a4a5a6a7a8a9aaabacadaeaf"
        "b0b1b2b3b4b5b6b7b8b9babbbcbdbebf"
        "c0c1c2c3c4c5c6c7c8c9cacbcccdcecf"
        "d0d1d2d3d4d5d6d7d8d9dadbdcdddedf"
        "e0e1e2e3e4e5e6e7e8e9eaebecedeeef"
        "f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff";

    buf[0] = '0';
    buf[1] = 'x';
    buf[2] = lut[(num & 0xFF) * 2];
	buf[3] = lut[(num & 0xFF) * 2 + 1];
	buf[4] = ',';
    return 5;
}

std::string replace(std::string str, const std::string& from, const std::string& to) {
    if (from.empty())
        return str;
    size_t start_pos = 0;
    while ((start_pos = str.find(from, start_pos)) != std::string::npos) {
        str.replace(start_pos, from.length(), to);
        start_pos += to.length();
    }
    return str;
}

ErrorCode convert(const OsString& input_file, const OsString& source_dir, const OsString& header_dir,
            std::string symbol_name, bool binary) {
    auto infile_name = fs::path(input_file.str()).filename().string();

    if (symbol_name.empty()) {
        symbol_name = fs::path(input_file.str()).filename().string();
		symbol_name = replace(symbol_name, ".", "_");
		symbol_name = replace(symbol_name, ":", "_");
		symbol_name = replace(symbol_name, ",", "_");
		symbol_name = replace(symbol_name, "-", "_");
		symbol_name = replace(symbol_name, " ", "_");
		symbol_name = replace(symbol_name, "Ä", "ae");
		symbol_name = replace(symbol_name, "ä", "ae");
		symbol_name = replace(symbol_name, "Ö", "oe");
		symbol_name = replace(symbol_name, "ö", "oe");
		symbol_name = replace(symbol_name, "Ü", "ue");
		symbol_name = replace(symbol_name, "ü", "ue");
		symbol_name = replace(symbol_name, "ß", "ss");
    }

    OsString header_file = fs::path(header_dir.str()).append(symbol_name).string() + ".h";
    OsString source_file = fs::path(source_dir.str()).append(symbol_name).string() + ".cpp";

    // Open input file to be embedded
    std::ifstream in(input_file.wstr(), binary ? (std::ios::in | std::ios::binary) : (std::ios::in));
    if (!in.is_open()) return ErrorCode::INPUT_FILE_FAILED;

    // Read the filesize
    std::string temp;                                       // Buffer is as large as file on-disk
	size_t filesize_temp = fs::file_size(input_file.str()); // -> Reading will make it smaller, but not larger  
    temp.resize(filesize_temp);         
    in.read(temp.data(), temp.size());  // Yes, the whole input file is read twice, but it's necessary
    size_t filesize = in.gcount();      //   and huge files are not supposed to be embedded anyways
    in.clear();             // Clear errors
	in.seekg(0, in.beg);    // And rewind to the beginning

    // Open output file (.cpp)
    fs::create_directories(fs::path(source_file.str()).parent_path().string());
    std::ofstream out(source_file.wstr(), std::ios::out);
    if (!out.is_open()) return ErrorCode::OUTPUT_FILE_FAILED;

    // Generate the source file
    out << "// File generated using battery_embed. https://github.com/HerrNamenlos123/Battery\n";
    out << "// Embedded file: " << fs::path(input_file.str()).filename().string() << " | filesize: "
        << filesize << " bytes | was embedded as binary: " << (binary ? "true" : "false") << "\n";
    out << "// Header file containing the declaration for retrieving the data: " + infile_name + ".h\n";
    out << "// DO NOT EDIT THIS FILE!!!\n";
    out << "\n#include <cinttypes>\n\n";
    out << "namespace Battery::Embed {\n\n";
    out << "const size_t __" << symbol_name << "_size = " << filesize << ";\n";
    out << "const uint8_t __" << symbol_name << "_data[] = {\n";
    out << "    ";
	
	// And now parse all bytes as fast as possible, this is performance intensive
    size_t bufferSize = 1024 * 64;  // 64kb chunks
    std::string outbuf;
    outbuf.resize(bufferSize * 5 + (bufferSize / 20 * 5) + 2); // Calculate the required buffer size
                                                           // 5 bytes per byte + 5 bytes every 20 bytes + 2 (\0)
    std::vector<char> inbuf(bufferSize, 0);
    while (!in.eof()) {
        in.read(inbuf.data(), inbuf.size());    // Read a chunk of the file
        size_t chunk_size = in.gcount();

		// And parse the chunk
        size_t index = 0;
        for (int i = 0; i < chunk_size; i++) {
            char c = inbuf.data()[i];
            index += write_hex_comma(outbuf.data() + index, c);

            if (i % 20 == 19) {
                strcpy(outbuf.data() + index, "\n    ");
                index += 5;
            }
        }
        out << std::string(outbuf.data(), index);
    }
    out << "\n};\n\n} // namespace Battery::Embed\n";


    // Open output file (.h)
    fs::create_directories(fs::path(header_file.str()).parent_path().string());
    std::ofstream header(header_file.wstr(), std::ios::out);
    if (!header.is_open()) return ErrorCode::OUTPUT_HEADER_FILE_FAILED;

    // Generate the header file
    header << "// File generated using battery_embed. https://github.com/HerrNamenlos123/Battery\n";
    header << "// Embedded file: " << fs::path(input_file.str()).filename().string() << " | filesize: "
           << filesize << " bytes | was embedded as binary: " << (binary ? "true" : "false") << "\n";
    header << "// Source file containing the data: " + infile_name + ".cpp\n";
    header << "// DO NOT EDIT THIS FILE!!!\n";
    header << "\n#ifndef __battery_embed_" + symbol_name + "_\n";
    header << "#define __battery_embed_" + symbol_name + "_\n\n";
    header << "#include <cinttypes>\n";
    header << "#include <iostream>\n";
    header << "#include <string>\n";
    header << "#include <vector>\n\n";
    header << "namespace Battery::Embed {\n\n";
    header << "    class " + symbol_name + "_t {\n";
    header << "    public:\n";
    header << "        " + symbol_name + "_t() = default;\n";
    header << "        static std::string str() {\n";
    header << "            return { reinterpret_cast<const char*>(__" + symbol_name + "_data), __" + symbol_name +
              "_size };\n";
    header << "        }\n";
    header << "        operator std::string() { return str(); }\n";
    header << "        \n";
    header << "        static std::vector<uint8_t> vec() {\n";
    header << "            return { __" + symbol_name + "_data, __" + symbol_name + "_data + __" + symbol_name +
              "_size };\n";
    header << "        }\n";
    header << "        operator std::vector<uint8_t>() { return vec(); }\n";
    header << "    };\n";
    header << "    std::ostream& operator<<(std::ostream& os, const " + symbol_name + "_t& data) { os << data.str(); return os; }\n\n";
    header << "    extern const size_t __" << symbol_name << "_size;\n";
    header << "    extern const uint8_t* __" << symbol_name << "_data;\n\n";
    header << "    inline " + symbol_name + "_t " + symbol_name + ";\n";
    header << "}\n";
    header << "#endif // __battery_embed_" + symbol_name + "_\n";

    return ErrorCode::SUCCESS;
}

int wmain(int argc, wchar_t** argv_raw) {

    CLI::App app{"Utility for converting Text and Binary files to C++ source files.\n"
                 "This is part of the Battery framework: https://github.com/HerrNamenlos123/Battery\n"};

    std::string input_file_raw;
    app.add_option("input_file", input_file_raw, "The file to be embedded")->required();

    std::string source_file_output_directory_raw;
    app.add_option("out_dir", source_file_output_directory_raw,
                   "Output dir for C++ source file")->required();

    std::string header_file_output_directory_raw;
    app.add_option("out_dir_header", header_file_output_directory_raw,
                   "Output dir for C++ header file (If omitted, the same output dir is used)");

    std::string symbol_name_raw;
    app.add_option("--symbol_name", symbol_name_raw, "Override the symbol name for the output files");

    bool binary = false;
    app.add_flag("--binary", binary,"File is in binary format instead of plain text (regarding line endings)");

	// Convert argv to UTF-8
    std::vector<OsString> argv_str;
    for (int i = 0; i < argc; i++) {
        argv_str.push_back(argv_raw[i]);
    }
    std::vector<const char*> argv;
    for (int i = 0; i < argc; i++) {
        argv.push_back(argv_str[i].c_str());
    }
	
	// Parse the CLI options
    CLI11_PARSE(app, argc, argv.data());

    if (header_file_output_directory_raw.empty()) {
        header_file_output_directory_raw = source_file_output_directory_raw;
    }
	
	// Convert file path string encoding (Windows -> Unix)
    OsString input_file = argv[1];
    OsString source_file_output_directory = source_file_output_directory_raw;
    OsString header_file_output_directory = header_file_output_directory_raw;
    OsString symbol_name = symbol_name_raw;

    ErrorCode status = convert(input_file, source_file_output_directory, header_file_output_directory, symbol_name, binary);
    switch (status) {
        case ErrorCode::SUCCESS: break;  // Success
        case ErrorCode::INPUT_FILE_FAILED: std::cerr << "Failed to open input file for reading (error code " << (int)status << ")" << std::endl; break;
        case ErrorCode::OUTPUT_HEADER_FILE_FAILED: std::cerr << "Failed to open header output file for writing (error code " << (int)status << ")" << std::endl; break;
        case ErrorCode::OUTPUT_FILE_FAILED: std::cerr << "Failed to open source output file for writing (error code " << (int)status << ")" << std::endl; break;
        default: std::cerr << "Unknown error code (error code " << (int)status << ")" << std::endl; break;
    }
    return (int)status;
}


// Here we "include" the source file, so it is compiled here in this translation unit
// Doing this to keep this a single cpp file and prevent code duplication, but we
// do not want to link to Battery. We only want to "steal" this module
#include "../src/Battery/Utils/OsString.cpp"