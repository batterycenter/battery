
#include "battery/core/all.hpp"

// TODO: Print version (add option)
// TODO: Create cache file besides executable, that remembers the hash of a file and does not overwrite if not necessary
// TODO: Support file encryption while embedding, for executable reverse-engineering security
// TODO: Support nested directories in the resource folder
// TODO: Move the generated function definitions from the header to the source files

enum class ErrorCode {
    SUCCESS = 0,
    INPUT_FILE_FAILED = -1,
    OUTPUT_FILE_FAILED = -2,
    OUTPUT_HEADER_FILE_FAILED = -3,
    INVALID_ARGUMENTS = -4
};

// Using lookup tables for converting ints to hex strings, for best performance
size_t write_hex_comma(char* buf, uint8_t num) {
    static std::string lut =
        "000102030405060708090a0b0c0d0e0f"
        "101112131415161718191a1b1c1d1e1f"
        "202122232425262728292a2b2c2d2e2f"
        "303132333435363738393a3b3c3d3e3f"
        "404142434445464748494a4b4c4d4e4f"
        "505152535455565758595a5b5c5d5e5f"
        "606162636465666768696a6b6c6d6e6f"
        "707172737475767778797a7b7c7d7e7f"
        "808182838485868788898a8b8c8d8e8f"
        "909192939495969798999a9b9c9d9e9f"
        "a0a1a2a3a4a5a6a7a8a9aaabacadaeaf"
        "b0b1b2b3b4b5b6b7b8b9babbbcbdbebf"
        "c0c1c2c3c4c5c6c7c8c9cacbcccdcecf"
        "d0d1d2d3d4d5d6d7d8d9dadbdcdddedf"
        "e0e1e2e3e4e5e6e7e8e9eaebecedeeef"
        "f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff";

    buf[0] = '0';
    buf[1] = 'x';
    buf[2] = lut[(num & 0xFF) * 2];
	buf[3] = lut[(num & 0xFF) * 2 + 1];
	buf[4] = ',';
    return 5;
}

std::u8string get_symbol_name(const b::fs::path& resource_file) {
    // Replace a few characters to create a valid C++ symbol name
    auto symbol = b::fs::path(resource_file).filename().u8string();
    symbol = b::replace(symbol, u8".", u8"_");
    symbol = b::replace(symbol, u8":", u8"_");
    symbol = b::replace(symbol, u8",", u8"_");
    symbol = b::replace(symbol, u8"-", u8"_");
    symbol = b::replace(symbol, u8" ", u8"_");
    symbol = b::replace(symbol, u8"Ä", u8"ae");
    symbol = b::replace(symbol, u8"ä", u8"ae");
    symbol = b::replace(symbol, u8"Ö", u8"oe");
    symbol = b::replace(symbol, u8"ö", u8"oe");
    symbol = b::replace(symbol, u8"Ü", u8"ue");
    symbol = b::replace(symbol, u8"ü", u8"ue");
    symbol = b::replace(symbol, u8"ß", u8"ss");
    return symbol;
}

std::pair<ErrorCode, std::u8string> generate_cpp(
        const b::fs::path& target_filename,
        const b::fs::path& resource_file,
        const std::u8string& symbol_name,
        bool binary
)
{
    // Open input file to be embedded
    b::fs::ifstream infile(resource_file, binary ? b::fs::Mode::BINARY : b::fs::Mode::TEXT);
    if (!infile.is_open()) {
        return {ErrorCode::INPUT_FILE_FAILED, resource_file.u8string()};
    }
    size_t filesize = infile.file_size();

    // Open output file for writing (.cpp)
    b::fs::ofstream outfile(target_filename, b::fs::Mode::TEXT);
    if (!outfile.is_open()) {
        return { ErrorCode::OUTPUT_FILE_FAILED, target_filename.u8string() + b::u8_from_std_string(strerror(errno)) };
    }

    std::string orifile = b::u8_as_str(resource_file.filename().u8string());
    std::string symb = b::u8_as_str(symbol_name);

    // Generate the source file
    outfile << fmt::format("// File generated using battery_embed. https://github.com/batterycenter/battery") << std::endl;
    outfile << fmt::format("// Embedded file: {} | filesize: {} bytes | was embedded as binary: {}", orifile, filesize, binary ? "true" : "false") << std::endl;
    outfile << fmt::format("// Header file containing the declaration for retrieving the data: {}.hpp", symb) << std::endl;
    outfile << fmt::format("// DO NOT EDIT THIS FILE!!!") << std::endl;
    outfile << std::endl;
    outfile << fmt::format("#include <cinttypes>") << std::endl;
    outfile << fmt::format("#include <cstddef>") << std::endl;
    outfile << std::endl;
    outfile << fmt::format("namespace resources::internal {{") << std::endl;
    outfile << std::endl;
    outfile << fmt::format("#ifndef BATTERY_PRODUCTION_MODE") << std::endl;
    outfile << fmt::format("    extern const char* __{}_filepath = \"{}\";", symb, b::u8_as_str(resource_file.u8string())) << std::endl;
    outfile << fmt::format("    extern const bool __{}_is_binary = {};", symb, binary ? "true" : "false") << std::endl;
    outfile << fmt::format("#endif") << std::endl;
    outfile << std::endl;
    outfile << fmt::format("    extern const size_t __{}_size = {};", symb, filesize) << std::endl;
    outfile << fmt::format("    extern const uint8_t __{}_data[] = {{", symb) << std::endl;
    outfile << fmt::format("    ");

    // And now parse all bytes as fast as possible, this part is computationally intensive
    size_t chunk_size = 1024 * 64;  // 64kb chunks
    std::string outbuffer;
    outbuffer.resize(chunk_size * 5 + (chunk_size / 20 * 5) + 2); // Calculate the required buffer size
    // 5 bytes per byte + 5 bytes every 20 bytes + 2 (\0)

    infile.read_in_chunks(chunk_size, [&outbuffer,&outfile] (std::string_view chunk) {
        // Parse each chunk of the file
        size_t index = 0;
        for (size_t i = 0; i < chunk.size(); i++) {
            index += write_hex_comma(outbuffer.data() + index, chunk[i]);

            if (i % 20 == 19) {
                strcpy(outbuffer.data() + index, "\n    ");
                index += 5;
            }
        }
        outfile << std::string(outbuffer.data(), index);
    });

    outfile << "\n};\n\n} // namespace resources::internal\n";
    return { ErrorCode::SUCCESS, u8"" };
}

std::pair<ErrorCode, std::u8string> generate_header(
        const b::fs::path& target_filename,
        const b::fs::path& resource_file,
        const std::u8string& symbol_name,
        bool binary
)
{
    // Open input file to be embedded
    b::fs::ifstream infile(resource_file, binary ? b::fs::Mode::BINARY : b::fs::Mode::TEXT);
    if (!infile.is_open()) {
        return {ErrorCode::INPUT_FILE_FAILED, resource_file.u8string()};
    }
    size_t filesize = infile.file_size();

    b::fs::ofstream file(target_filename, b::fs::Mode::TEXT);
    if (!file.is_open()) {
        return { ErrorCode::OUTPUT_HEADER_FILE_FAILED, target_filename.u8string() };
    }

    std::string orifile = b::u8_as_str(resource_file.filename().u8string());
    std::string symb = b::u8_as_str(symbol_name);

    // Generate the header file
    file << fmt::format("// File generated using battery_embed. https://github.com/batterycenter/battery") << std::endl;
    file << fmt::format("// Embedded file: {} | filesize: {} bytes | was embedded as binary: {}", orifile, filesize, binary ? "true" : "false") << std::endl;
    file << fmt::format("// Source file containing the data: {}.cpp", symb) << std::endl;
    file << fmt::format("// DO NOT EDIT THIS FILE!!!") << std::endl;
    file << std::endl;
    file << fmt::format("#ifndef __battery_embed_{}_", symb) << std::endl;
    file << fmt::format("#define __battery_embed_{}_", symb) << std::endl;
    file << std::endl;
    file << fmt::format("#include <cinttypes>") << std::endl;
    file << fmt::format("#include <iostream>") << std::endl;
    file << fmt::format("#include <string>") << std::endl;
    file << fmt::format("#include <vector>") << std::endl;
    file << fmt::format("#include \"battery/core/resource.hpp\"") << std::endl;
    file << fmt::format("#include \"battery/core/fs.hpp\"") << std::endl;
    file << std::endl;
    file << fmt::format("namespace resources {{") << std::endl;
    file << fmt::format("    namespace internal {{") << std::endl;
    file << std::endl;
    file << fmt::format("#ifndef BATTERY_PRODUCTION_MODE") << std::endl;
    file << fmt::format("        extern const char* __{}_filepath;", symb) << std::endl;
    file << fmt::format("        extern const bool __{}_is_binary;", symb) << std::endl;
    file << fmt::format("#endif") << std::endl;
    file << std::endl;
    file << fmt::format("        extern const size_t __{}_size;", symb) << std::endl;
    file << fmt::format("        extern const uint8_t __{}_data[];", symb) << std::endl;
    file << std::endl;
    file << fmt::format("        class {}_t {{", symb) << std::endl;
    file << fmt::format("        public:") << std::endl;
    file << fmt::format("            {}_t() = default;", symb) << std::endl;
    file << std::endl;
    file << fmt::format("            inline static std::string str() {{") << std::endl;
    file << fmt::format("                return {{ reinterpret_cast<const char*>(__{}_data), __{}_size }};", symb, symb) << std::endl;
    file << fmt::format("            }}") << std::endl;
    file << std::endl;
    file << fmt::format("            inline operator std::string() {{") << std::endl;
    file << fmt::format("                return str();") << std::endl;
    file << fmt::format("            }}") << std::endl;
    file << std::endl;
    file << fmt::format("            inline static std::vector<uint8_t> vec() {{") << std::endl;
    file << fmt::format("                return {{ __{}_data, __{}_data + __{}_size }};", symb, symb, symb) << std::endl;
    file << fmt::format("            }}") << std::endl;
    file << std::endl;
    file << fmt::format("            inline operator std::vector<uint8_t>() {{") << std::endl;
    file << fmt::format("                return vec();") << std::endl;
    file << fmt::format("            }}") << std::endl;
    file << std::endl;
    file << fmt::format("#ifndef BATTERY_PRODUCTION_MODE") << std::endl;
    file << fmt::format("            inline static b::fs::path filepath() {{") << std::endl;
    file << fmt::format("                return __{}_filepath;", symb) << std::endl;
    file << fmt::format("            }}") << std::endl;
    file << std::endl;
    file << fmt::format("            inline static bool is_binary() {{") << std::endl;
    file << fmt::format("                return __{}_is_binary;", symb) << std::endl;
    file << fmt::format("            }}") << std::endl;
    file << fmt::format("#endif") << std::endl;
    file << std::endl;
    file << fmt::format("            inline operator b::resource() {{") << std::endl;
    file << fmt::format("                return b::resource::from_byte_string(str());") << std::endl;
    file << fmt::format("            }}") << std::endl;
    file << std::endl;
    file << fmt::format("            inline size_t size() {{") << std::endl;
    file << fmt::format("                return str().size();") << std::endl;
    file << fmt::format("            }}") << std::endl;
    file << fmt::format("        }};") << std::endl;
    file << fmt::format("        inline std::ostream& operator<<(std::ostream& os, const {}_t& data) {{ os << data.str(); return os; }}\n", symb) << std::endl;
    file << fmt::format("    }};") << std::endl;
    file << fmt::format("    inline internal::{}_t {};", symb, symb) << std::endl;
    file << fmt::format("}}") << std::endl;
    file << fmt::format("#endif // __battery_embed_{}_", symb) << std::endl;

    return { ErrorCode::SUCCESS, u8"" };
}

std::pair<ErrorCode, std::u8string> generate_files(
        const b::fs::path& resource_file,
        const b::fs::path& target_file,
        std::u8string symbol_name,
        bool binary,
        bool header
) {
    if (symbol_name.empty()) {
        symbol_name = get_symbol_name(resource_file);
    }

    if (header) {
        return generate_header(target_file, resource_file, symbol_name, binary);
    }
    else {
        return generate_cpp(target_file, resource_file, symbol_name, binary);
    }
}

int b::main(const std::vector<std::u8string>& args) {             // NOLINT NOSONAR
    
    CLI::App app{"Utility for converting Text and Binary files to C++ source files.\n"
                 "This is part of the battery software stack: https://github.com/batterycenter/battery\n"};

    std::string resource_file;
    app.add_option("resource file", resource_file, "The file to be embedded")->required()->check(CLI::ExistingFile);

    std::string target_file;
    app.add_option("c++ target file", target_file,"The C++ target source file or header file (depending on --header and --cpp)")->required();

    std::string symbol_name;
    app.add_option("--symbol_name", symbol_name, "Override the symbol name for the output files");

    bool binary = false;
    app.add_flag("--binary", binary, "File is in binary format instead of plain text (regarding line endings)");

    bool header = false;
    app.add_flag("--header", header, "Only generate the header without the source file");

    bool cpp = false;
    app.add_flag("--cpp", cpp, "Only generate the source file without the header");

    // Parse the CLI options
    CLI11_PARSE(app, args.size(), b::args_to_argv(args));

    if ((header && cpp) || (!header && !cpp)) {
        b::log::error("Error {} (INVALID_ARGUMENTS): You must specify exactly one of --header or --cpp!", (int)ErrorCode::INVALID_ARGUMENTS);
        return (int)ErrorCode::INVALID_ARGUMENTS;
    }

    auto [status, error] = generate_files(
            resource_file,
            target_file,
            b::u8_from_std_string(symbol_name),
            binary,
            header);

    switch (status) {

        using enum ErrorCode;
        case SUCCESS:
            break;  // Success

        case INPUT_FILE_FAILED:
            b::log::error("Failed to open input file for reading (error code {}): {}", (int)status, b::u8_as_str(error));
            break;

        case OUTPUT_HEADER_FILE_FAILED:
            b::log::error("Failed to open header output file for writing (error code {}): {}", (int)status, b::u8_as_str(error));
            break;

        case OUTPUT_FILE_FAILED:
            b::log::error("Failed to open source output file for writing (error code {}): {}", (int)status, b::u8_as_str(error));
            break;

        default:
            b::log::error("Unknown error (error code {}): {}", (int)status, b::u8_as_str(error));
            break;
    }
    return (int)status;
}
