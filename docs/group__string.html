<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Battery: String</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript" src="toggle-alternative-theme.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/batterycenter/battery" class="github-corner" title="View source on GitHub" target="_blank">
    <svg viewBox="0 0 250 250" width="40" height="40" style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="battery.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Battery
   &#160;<span id="projectnumber">v0.1.2-alpha</span>
   </div>
   <div id="projectbrief">Desktop application framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__string.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">String</div>  </div>
</div><!--header-->
<div class="contents">

<p>Everything related to string manipulation and encoding.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga61a14888dd093388872c16651f0f4bd1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga61a14888dd093388872c16651f0f4bd1">b::osstring</a> = std::string</td></tr>
<tr class="memdesc:ga61a14888dd093388872c16651f0f4bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A string type used for interfacing with the corresponding operating system.  <a href="group__string.html#ga61a14888dd093388872c16651f0f4bd1">More...</a><br /></td></tr>
<tr class="separator:ga61a14888dd093388872c16651f0f4bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3ca612ae19ec07a2bdc8352b30d762f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__string.html#ga61a14888dd093388872c16651f0f4bd1">b::osstring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga3ca612ae19ec07a2bdc8352b30d762f5">b::to_osstring</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga3ca612ae19ec07a2bdc8352b30d762f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a UTF-8 <code>std::string</code> to its platform agnostic version.  <a href="group__string.html#ga3ca612ae19ec07a2bdc8352b30d762f5">More...</a><br /></td></tr>
<tr class="separator:ga3ca612ae19ec07a2bdc8352b30d762f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20793a985603bef8f8f2a772f427c1b0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga20793a985603bef8f8f2a772f427c1b0">b::from_osstring</a> (const <a class="el" href="group__string.html#ga61a14888dd093388872c16651f0f4bd1">b::osstring</a> &amp;str)</td></tr>
<tr class="memdesc:ga20793a985603bef8f8f2a772f427c1b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opposite of <code><a class="el" href="group__string.html#ga3ca612ae19ec07a2bdc8352b30d762f5" title="Convert a UTF-8 std::string to its platform agnostic version.">b::to_osstring()</a></code>. See for more info.  <a href="group__string.html#ga20793a985603bef8f8f2a772f427c1b0">More...</a><br /></td></tr>
<tr class="separator:ga20793a985603bef8f8f2a772f427c1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cfd792ba8468e47106391bf93d6f07e"><td class="memItemLeft" align="right" valign="top">std::u32string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga9cfd792ba8468e47106391bf93d6f07e">b::to_u32</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga9cfd792ba8468e47106391bf93d6f07e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a UTF-8 encoded multibyte string to a UTF-32 encoded string.  <a href="group__string.html#ga9cfd792ba8468e47106391bf93d6f07e">More...</a><br /></td></tr>
<tr class="separator:ga9cfd792ba8468e47106391bf93d6f07e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc56123bb66b1d7ca32e6beeccf02469"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#gacc56123bb66b1d7ca32e6beeccf02469">b::to_u8</a> (const std::u32string &amp;str)</td></tr>
<tr class="memdesc:gacc56123bb66b1d7ca32e6beeccf02469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a UTF-32 encoded string back to a UTF-8 encoded string.  <a href="group__string.html#gacc56123bb66b1d7ca32e6beeccf02469">More...</a><br /></td></tr>
<tr class="separator:gacc56123bb66b1d7ca32e6beeccf02469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78a79386ae94f195c3ffea648f388db2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga78a79386ae94f195c3ffea648f388db2">b::to_u8</a> (char32_t c)</td></tr>
<tr class="memdesc:ga78a79386ae94f195c3ffea648f388db2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a single unicode character into its UTF-8 encoded multibyte form.  <a href="group__string.html#ga78a79386ae94f195c3ffea648f388db2">More...</a><br /></td></tr>
<tr class="separator:ga78a79386ae94f195c3ffea648f388db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58b1ee5c564cafece2371b643c6cd295"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga58b1ee5c564cafece2371b643c6cd295">b::u8_foreach</a> (const std::string &amp;str, const std::function&lt; std::variant&lt; std::string, char32_t &gt;(std::string)&gt; &amp;function)</td></tr>
<tr class="memdesc:ga58b1ee5c564cafece2371b643c6cd295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a function for every character in a UTF-8 encoded string.  <a href="group__string.html#ga58b1ee5c564cafece2371b643c6cd295">More...</a><br /></td></tr>
<tr class="separator:ga58b1ee5c564cafece2371b643c6cd295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf059bea799f2e29a74d02e8124d5cf66"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#gaf059bea799f2e29a74d02e8124d5cf66">b::u8_foreach</a> (const std::string &amp;str, const std::function&lt; std::variant&lt; std::string, char32_t &gt;(char32_t)&gt; &amp;function)</td></tr>
<tr class="memdesc:gaf059bea799f2e29a74d02e8124d5cf66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a function for every character in a UTF-8 encoded string. Check the overload for more info.  <a href="group__string.html#gaf059bea799f2e29a74d02e8124d5cf66">More...</a><br /></td></tr>
<tr class="separator:gaf059bea799f2e29a74d02e8124d5cf66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga815d742dd731ef1857d5146204cb0990"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga815d742dd731ef1857d5146204cb0990">b::split</a> (std::string str, const std::string &amp;delimiter)</td></tr>
<tr class="memdesc:ga815d742dd731ef1857d5146204cb0990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a string into an array of string pieces by a delimiter.  <a href="group__string.html#ga815d742dd731ef1857d5146204cb0990">More...</a><br /></td></tr>
<tr class="separator:ga815d742dd731ef1857d5146204cb0990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e95ddc224e06adbcdc28b997c9184ce"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga7e95ddc224e06adbcdc28b997c9184ce">b::join</a> (const std::vector&lt; std::string &gt; &amp;strings, const std::string &amp;spacer=&quot;&quot;)</td></tr>
<tr class="memdesc:ga7e95ddc224e06adbcdc28b997c9184ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join an array of strings into a single one. To be used with <code><a class="el" href="group__string.html#ga815d742dd731ef1857d5146204cb0990" title="Split a string into an array of string pieces by a delimiter.">b::split()</a></code>.  <a href="group__string.html#ga7e95ddc224e06adbcdc28b997c9184ce">More...</a><br /></td></tr>
<tr class="separator:ga7e95ddc224e06adbcdc28b997c9184ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00199551bb2ca5e5864257ad28a8cbad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga00199551bb2ca5e5864257ad28a8cbad">b::replace</a> (std::string string, const std::string &amp;from, const std::string &amp;to)</td></tr>
<tr class="memdesc:ga00199551bb2ca5e5864257ad28a8cbad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace parts of a string with another string.  <a href="group__string.html#ga00199551bb2ca5e5864257ad28a8cbad">More...</a><br /></td></tr>
<tr class="separator:ga00199551bb2ca5e5864257ad28a8cbad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05d0a2abdba4ddee5cf78cd59fab4f49"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga05d0a2abdba4ddee5cf78cd59fab4f49">b::replace_one</a> (std::string string, const std::string &amp;from, const std::string &amp;to, int occurrence)</td></tr>
<tr class="memdesc:ga05d0a2abdba4ddee5cf78cd59fab4f49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace one part of a string with another string.  <a href="group__string.html#ga05d0a2abdba4ddee5cf78cd59fab4f49">More...</a><br /></td></tr>
<tr class="separator:ga05d0a2abdba4ddee5cf78cd59fab4f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c0d689a4f54058882aa4dcbeb348e41"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga8c0d689a4f54058882aa4dcbeb348e41">b::replace_first</a> (const std::string &amp;string, const std::string &amp;from, const std::string &amp;to)</td></tr>
<tr class="memdesc:ga8c0d689a4f54058882aa4dcbeb348e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the first occurrence of a string with another string.  <a href="group__string.html#ga8c0d689a4f54058882aa4dcbeb348e41">More...</a><br /></td></tr>
<tr class="separator:ga8c0d689a4f54058882aa4dcbeb348e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87ede38a0c232d547410a3e1a9a43252"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga87ede38a0c232d547410a3e1a9a43252">b::replace_last</a> (const std::string &amp;string, const std::string &amp;from, const std::string &amp;to)</td></tr>
<tr class="memdesc:ga87ede38a0c232d547410a3e1a9a43252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the last occurrence of a string with another string.  <a href="group__string.html#ga87ede38a0c232d547410a3e1a9a43252">More...</a><br /></td></tr>
<tr class="separator:ga87ede38a0c232d547410a3e1a9a43252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20b0197a9e4ed6b0bebb0a91d8826061"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga20b0197a9e4ed6b0bebb0a91d8826061">b::from_u8string</a> (const std::u8string &amp;str)</td></tr>
<tr class="memdesc:ga20b0197a9e4ed6b0bebb0a91d8826061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an <code>std::u8string</code> to an <code>std::string</code>.  <a href="group__string.html#ga20b0197a9e4ed6b0bebb0a91d8826061">More...</a><br /></td></tr>
<tr class="separator:ga20b0197a9e4ed6b0bebb0a91d8826061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6a3f2785e3086dd95d97460418a0bef"><td class="memItemLeft" align="right" valign="top">std::u8string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#gad6a3f2785e3086dd95d97460418a0bef">b::to_u8string</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:gad6a3f2785e3086dd95d97460418a0bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an <code>std::string</code> to an <code>std::u8string</code>.  <a href="group__string.html#gad6a3f2785e3086dd95d97460418a0bef">More...</a><br /></td></tr>
<tr class="separator:gad6a3f2785e3086dd95d97460418a0bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0febb799fd526dbaae7981b9bb8a78ba"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga0febb799fd526dbaae7981b9bb8a78ba">b::to_lower</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga0febb799fd526dbaae7981b9bb8a78ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make all characters of a UTF-8 string lowercase.  <a href="group__string.html#ga0febb799fd526dbaae7981b9bb8a78ba">More...</a><br /></td></tr>
<tr class="separator:ga0febb799fd526dbaae7981b9bb8a78ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c7a4968814fc4e9b2a8788e90393840"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga6c7a4968814fc4e9b2a8788e90393840">b::to_upper</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga6c7a4968814fc4e9b2a8788e90393840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make all characters of a UTF-8 string uppercase.  <a href="group__string.html#ga6c7a4968814fc4e9b2a8788e90393840">More...</a><br /></td></tr>
<tr class="separator:ga6c7a4968814fc4e9b2a8788e90393840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade7c5a7f45c7e461f5599b17ce657a8a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#gade7c5a7f45c7e461f5599b17ce657a8a">b::encode_base64</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:gade7c5a7f45c7e461f5599b17ce657a8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode a string or a binary resource as Base-64.  <a href="group__string.html#gade7c5a7f45c7e461f5599b17ce657a8a">More...</a><br /></td></tr>
<tr class="separator:gade7c5a7f45c7e461f5599b17ce657a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b3508d763f1f1e50d76f741bef96570"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga9b3508d763f1f1e50d76f741bef96570">b::decode_base64</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga9b3508d763f1f1e50d76f741bef96570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a Base-64 encoded resource back to its original form.  <a href="group__string.html#ga9b3508d763f1f1e50d76f741bef96570">More...</a><br /></td></tr>
<tr class="separator:ga9b3508d763f1f1e50d76f741bef96570"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Everything related to string manipulation and encoding. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga61a14888dd093388872c16651f0f4bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61a14888dd093388872c16651f0f4bd1">&#9670;&nbsp;</a></span>osstring</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__string.html#ga61a14888dd093388872c16651f0f4bd1">b::osstring</a> = typedef std::string</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A string type used for interfacing with the corresponding operating system. </p>
<p>This type is defined as <code>std::wstring</code> on Windows, designed to hold UTF-16 encoded strings for working with the Win32 API exclusively. On all other platforms it is defined as <code>std::string</code>. Thus, <code>b::to_osstring(str).c_str()</code> will always give you a c-style char array, UTF-8 on Unix and UTF-16 on Windows. See <code>b::to_osstring</code> for possible caveats! </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__string.html#ga3ca612ae19ec07a2bdc8352b30d762f5" title="Convert a UTF-8 std::string to its platform agnostic version.">b::to_osstring()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga9b3508d763f1f1e50d76f741bef96570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b3508d763f1f1e50d76f741bef96570">&#9670;&nbsp;</a></span>decode_base64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string b::decode_base64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a Base-64 encoded resource back to its original form. </p>
<p>See <a class="el" href="group__string.html#gade7c5a7f45c7e461f5599b17ce657a8a" title="Encode a string or a binary resource as Base-64.">b::encode_base64()</a> for more information </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>A Base-64 encoded string representing a resource </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Decoded resource as a string containing a series of bytes (not necessarily printable characters). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__string.html#gade7c5a7f45c7e461f5599b17ce657a8a" title="Encode a string or a binary resource as Base-64.">b::encode_base64()</a> </dd></dl>

</div>
</div>
<a id="gade7c5a7f45c7e461f5599b17ce657a8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade7c5a7f45c7e461f5599b17ce657a8a">&#9670;&nbsp;</a></span>encode_base64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string b::encode_base64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode a string or a binary resource as Base-64. </p>
<p>This string can either be a text or a binary-like byte-series (loaded from a file). Especially useful for embedding small resource files in a source file or exchanging binary resources over a network. The binary resource is stored in the std::string as a series of bytes, <code>std::string</code> can also hold non-printable characters including zero bytes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>The string or byte-series to encode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Encoded Base-64 string </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__string.html#ga9b3508d763f1f1e50d76f741bef96570" title="Decode a Base-64 encoded resource back to its original form.">b::decode_base64()</a> </dd></dl>

</div>
</div>
<a id="ga20793a985603bef8f8f2a772f427c1b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20793a985603bef8f8f2a772f427c1b0">&#9670;&nbsp;</a></span>from_osstring()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string b::from_osstring </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__string.html#ga61a14888dd093388872c16651f0f4bd1">b::osstring</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opposite of <code><a class="el" href="group__string.html#ga3ca612ae19ec07a2bdc8352b30d762f5" title="Convert a UTF-8 std::string to its platform agnostic version.">b::to_osstring()</a></code>. See for more info. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>The string to be converted, std::wstring on Windows, std::string on other platforms </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>on an invalid utf-16 sequence on Windows, none on other platforms </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted string </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__string.html#ga3ca612ae19ec07a2bdc8352b30d762f5" title="Convert a UTF-8 std::string to its platform agnostic version.">b::to_osstring()</a> </dd></dl>

</div>
</div>
<a id="ga20b0197a9e4ed6b0bebb0a91d8826061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20b0197a9e4ed6b0bebb0a91d8826061">&#9670;&nbsp;</a></span>from_u8string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string b::from_u8string </td>
          <td>(</td>
          <td class="paramtype">const std::u8string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an <code>std::u8string</code> to an <code>std::string</code>. </p>
<p>The returned string is a one-to-one copy of the UTF-8 encoded bytes. No encoding is changed and no check is performed. This function cannot fail. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>The string to be converted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted string </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__string.html#gad6a3f2785e3086dd95d97460418a0bef" title="Convert an std::string to an std::u8string.">b::to_u8string()</a> </dd></dl>

</div>
</div>
<a id="ga7e95ddc224e06adbcdc28b997c9184ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e95ddc224e06adbcdc28b997c9184ce">&#9670;&nbsp;</a></span>join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string b::join </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>strings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>spacer</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join an array of strings into a single one. To be used with <code><a class="el" href="group__string.html#ga815d742dd731ef1857d5146204cb0990" title="Split a string into an array of string pieces by a delimiter.">b::split()</a></code>. </p>
<p>The spacer string is inserted between any two string tokens being joined. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">strings</td><td>Array of string tokens to be joined </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spacer</td><td>Spacer string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The combined string </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__string.html#ga815d742dd731ef1857d5146204cb0990" title="Split a string into an array of string pieces by a delimiter.">b::split()</a> </dd></dl>

</div>
</div>
<a id="ga00199551bb2ca5e5864257ad28a8cbad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00199551bb2ca5e5864257ad28a8cbad">&#9670;&nbsp;</a></span>replace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string b::replace </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace parts of a string with another string. </p>
<p>The parameter <code>string</code> is iterated over and any occurrences of <code>from</code> are replaced by <code>to</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>The string to be modified </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">from</td><td>A token to be replaced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">to</td><td>What to replace the token with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The modified string </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__string.html#ga05d0a2abdba4ddee5cf78cd59fab4f49" title="Replace one part of a string with another string.">b::replace_one()</a> </dd></dl>

</div>
</div>
<a id="ga8c0d689a4f54058882aa4dcbeb348e41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c0d689a4f54058882aa4dcbeb348e41">&#9670;&nbsp;</a></span>replace_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string b::replace_first </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the first occurrence of a string with another string. </p>
<p>Please see <code><a class="el" href="group__string.html#ga05d0a2abdba4ddee5cf78cd59fab4f49" title="Replace one part of a string with another string.">b::replace_one()</a></code>. This function is just a specialization with the last parameter already set. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__string.html#ga87ede38a0c232d547410a3e1a9a43252" title="Replace the last occurrence of a string with another string.">b::replace_last()</a> </dd></dl>

</div>
</div>
<a id="ga87ede38a0c232d547410a3e1a9a43252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87ede38a0c232d547410a3e1a9a43252">&#9670;&nbsp;</a></span>replace_last()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string b::replace_last </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the last occurrence of a string with another string. </p>
<p>Please see <code><a class="el" href="group__string.html#ga05d0a2abdba4ddee5cf78cd59fab4f49" title="Replace one part of a string with another string.">b::replace_one()</a></code>. This function is just a specialization with the last parameter already set. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__string.html#ga8c0d689a4f54058882aa4dcbeb348e41" title="Replace the first occurrence of a string with another string.">b::replace_first()</a> </dd></dl>

</div>
</div>
<a id="ga05d0a2abdba4ddee5cf78cd59fab4f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05d0a2abdba4ddee5cf78cd59fab4f49">&#9670;&nbsp;</a></span>replace_one()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string b::replace_one </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>occurrence</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace one part of a string with another string. </p>
<p>The parameter <code>string</code> is iterated over and only one occurrence of the string <code>from</code> is replaced with the string <code>to</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>The string to be modified </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">from</td><td>A token to be replaced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">to</td><td>What to replace the token with </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">occurrence</td><td>The index of the occurrence. 0 would mean the first occurrence, 1 the second. Additionally, -1 would be the last occurrence and -2 the second-to-last. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The modified string </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__string.html#ga00199551bb2ca5e5864257ad28a8cbad" title="Replace parts of a string with another string.">b::replace()</a> </dd>
<dd>
<a class="el" href="group__string.html#ga8c0d689a4f54058882aa4dcbeb348e41" title="Replace the first occurrence of a string with another string.">b::replace_first()</a> </dd></dl>

</div>
</div>
<a id="ga815d742dd731ef1857d5146204cb0990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga815d742dd731ef1857d5146204cb0990">&#9670;&nbsp;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; b::split </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delimiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split a string into an array of string pieces by a delimiter. </p>
<p>When no delimiter is found, only the input string is returned. Several delimiters in a row are treated as a single one. The delimeter can be one or more bytes, thus this function is UTF-8 conformant. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>The string to be split </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delimiter</td><td>The characters to split the string at </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array of string tokens </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__string.html#ga7e95ddc224e06adbcdc28b997c9184ce" title="Join an array of strings into a single one. To be used with b::split().">b::join()</a> </dd></dl>

</div>
</div>
<a id="ga0febb799fd526dbaae7981b9bb8a78ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0febb799fd526dbaae7981b9bb8a78ba">&#9670;&nbsp;</a></span>to_lower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string b::to_lower </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make all characters of a UTF-8 string lowercase. </p>
<p>Unicode characters are transformed like expected. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>The UTF-8 string to be converted </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>on an invalid UTF-8 sequence </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted UTF-8 string </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__string.html#ga6c7a4968814fc4e9b2a8788e90393840" title="Make all characters of a UTF-8 string uppercase.">b::to_upper()</a> </dd></dl>

</div>
</div>
<a id="ga3ca612ae19ec07a2bdc8352b30d762f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ca612ae19ec07a2bdc8352b30d762f5">&#9670;&nbsp;</a></span>to_osstring()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__string.html#ga61a14888dd093388872c16651f0f4bd1">b::osstring</a> b::to_osstring </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a UTF-8 <code>std::string</code> to its platform agnostic version. </p>
<p>Converting to UTF-16 on Windows, returning the unchanged string on other platforms. <code>b::to_osstring(str).c_str()</code> will always give you a c-style char array, UTF-8 on Unix and UTF-16 on Windows. But beware of the lifetime, in this case the pointer is only valid as long as the osstring object is alive and it only is for the current expression. Thus, if you have a Win32 API or Linux API function that holds onto the pointer or you store the pointer in a struct, then you must save the osstring in a variable, call <code>.c_str()</code> on the variable and make sure that the variable outlives the data structure. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>The string to be converted </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>on an invalid utf-8 sequence on Windows, nothing on other platforms </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::wstring on Windows converted to UTF-16, std::string on other platforms with the unchanged string </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__string.html#ga20793a985603bef8f8f2a772f427c1b0" title="Opposite of b::to_osstring(). See for more info.">b::from_osstring()</a> </dd></dl>

</div>
</div>
<a id="ga9cfd792ba8468e47106391bf93d6f07e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cfd792ba8468e47106391bf93d6f07e">&#9670;&nbsp;</a></span>to_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::u32string b::to_u32 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a UTF-8 encoded multibyte string to a UTF-32 encoded string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>The string to be converted </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>on an invalid UTF-8 sequence </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted string </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__string.html#ga78a79386ae94f195c3ffea648f388db2" title="Convert a single unicode character into its UTF-8 encoded multibyte form.">b::to_u8()</a> </dd></dl>

</div>
</div>
<a id="ga78a79386ae94f195c3ffea648f388db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78a79386ae94f195c3ffea648f388db2">&#9670;&nbsp;</a></span>to_u8() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string b::to_u8 </td>
          <td>(</td>
          <td class="paramtype">char32_t&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a single unicode character into its UTF-8 encoded multibyte form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The character to be converted </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>on an invalid unicode character </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The UTF-8 multibyte string representing the unicode character </dd></dl>

</div>
</div>
<a id="gacc56123bb66b1d7ca32e6beeccf02469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc56123bb66b1d7ca32e6beeccf02469">&#9670;&nbsp;</a></span>to_u8() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string b::to_u8 </td>
          <td>(</td>
          <td class="paramtype">const std::u32string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a UTF-32 encoded string back to a UTF-8 encoded string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>The string to be converted </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>on an invalid UTF-32 character </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted string </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__string.html#ga9cfd792ba8468e47106391bf93d6f07e" title="Convert a UTF-8 encoded multibyte string to a UTF-32 encoded string.">b::to_u32()</a> </dd></dl>

</div>
</div>
<a id="gad6a3f2785e3086dd95d97460418a0bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6a3f2785e3086dd95d97460418a0bef">&#9670;&nbsp;</a></span>to_u8string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::u8string b::to_u8string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an <code>std::string</code> to an <code>std::u8string</code>. </p>
<p>The input is expected to be a string containing UTF-8 encoded bytes. If the input contains an invalid UTF-8 sequence, an exception is thrown. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>The string to be converted </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>on an invalid UTF-8 sequence </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted string. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__string.html#ga20b0197a9e4ed6b0bebb0a91d8826061" title="Convert an std::u8string to an std::string.">b::from_u8string()</a> </dd></dl>

</div>
</div>
<a id="ga6c7a4968814fc4e9b2a8788e90393840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c7a4968814fc4e9b2a8788e90393840">&#9670;&nbsp;</a></span>to_upper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string b::to_upper </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make all characters of a UTF-8 string uppercase. </p>
<p>Unicode characters are transformed like expected. "ß" is transformed to "SS". </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>The UTF-8 string to be converted </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>on an invalid UTF-8 sequence </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted UTF-8 string </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__string.html#ga0febb799fd526dbaae7981b9bb8a78ba" title="Make all characters of a UTF-8 string lowercase.">b::to_lower()</a> </dd></dl>

</div>
</div>
<a id="gaf059bea799f2e29a74d02e8124d5cf66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf059bea799f2e29a74d02e8124d5cf66">&#9670;&nbsp;</a></span>u8_foreach() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string b::u8_foreach </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; std::variant&lt; std::string, char32_t &gt;(char32_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a function for every character in a UTF-8 encoded string. Check the overload for more info. </p>
<p>This is an overload that supplies the callback with <code>char32_t</code> instead of <code>std::string</code>. Please see <code><a class="el" href="group__string.html#gaf059bea799f2e29a74d02e8124d5cf66" title="Call a function for every character in a UTF-8 encoded string. Check the overload for more info.">b::u8_foreach()</a></code> for any other details. </p>

</div>
</div>
<a id="ga58b1ee5c564cafece2371b643c6cd295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58b1ee5c564cafece2371b643c6cd295">&#9670;&nbsp;</a></span>u8_foreach() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string b::u8_foreach </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; std::variant&lt; std::string, char32_t &gt;(std::string)&gt; &amp;&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a function for every character in a UTF-8 encoded string. </p>
<p>This can be used to do operations on a string whereas the function is called for every character (not for every byte). The return values are appended to one another and returned as another string. Thus, directly returning the character in the callback would make this function return the string unchanged. The callback can return either a char32_t or a UTF-8 string, whereas the string can also have more or fewer characters. Returning <code>""</code> essentially removes it. Example usage: <code>auto new = b::u8_foreach(str, [] (std::string c) { return c == "ß" ? "SS" : c; })</code> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>The string over which to iterate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>A callback which is called for every character or codepoint in the string </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>on an invalid UTF-8 sequence </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>All return values from the callbacks appended into a string </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
